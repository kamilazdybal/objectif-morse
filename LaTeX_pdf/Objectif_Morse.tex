\documentclass[12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{epsf}
\usepackage{float}
\usepackage{geometry}
\geometry{hmargin=3.5cm, vmargin=2.5cm}
\usepackage[squaren]{SIunits}
\usepackage{listings}
\usepackage{color}
\definecolor{mygreen}{RGB}{70, 180, 90}
\definecolor{mylilas}{RGB}{255, 117, 45}
\definecolor{cadr}{rgb}{0.89, 0.0, 0.13}

\graphicspath{{DWGs/}}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{framed}
\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.95,0.95,0.95}
\definecolor{shadecolor}{RGB}{224, 224, 224}
\usepackage{hyperref}
\usepackage{soul}

\begin{document}

\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\lstset{
backgroundcolor=\color{lbcolor},
    tabsize=4,    
%   rulecolor=,
    language=[GNU]C++,
        basicstyle=\scriptsize,
        upquote=true,
        aboveskip={1.5\baselineskip},
        columns=fixed,
        showstringspaces=false,
        extendedchars=false,
        breaklines=true,
        prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
        frame=single,
        numbers=left,
        showtabs=false,
        showspaces=false,
        showstringspaces=false,
        identifierstyle=\ttfamily,
        keywordstyle=\color[rgb]{0,0,1},
        commentstyle=\color[rgb]{0.026,0.112,0.095},
        stringstyle=\color[rgb]{0.627,0.126,0.941},
        numberstyle=\color[rgb]{0.205, 0.142, 0.73},
%        \lstdefinestyle{C++}{language=C++,style=numbers}’.
}
\lstset{
    backgroundcolor=\color{lbcolor},
    tabsize=4,
  language=C++,
  captionpos=b,
  tabsize=3,
  frame=lines,
  numbers=left,
  numberstyle=\tiny,
  numbersep=5pt,
  breaklines=true,
  showstringspaces=false,
  basicstyle=\footnotesize,
%  identifierstyle=\color{magenta},
  keywordstyle=\color[rgb]{0,0,1},
  commentstyle=\color{Darkgreen},
  stringstyle=\color{red}
  }

\begin{titlepage}
    \begin{center}

		\vspace*{5cm}    

        \Huge
        \textbf{Objectif Morse}
        
        \vspace*{0.5cm}

		\Large

		\textbf{
		\text{-}\text{-}\text{-} \,			%O
		$\cdot\cdot$\text{-} \,\,\,\,\,\,	%U
		$\cdot\cdot\cdot\cdot$ \,			%H
		$\cdot\cdot$ \,						%I
		$\cdot\cdot\cdot$ \,				%S
		\text{-} \,							%T
		\text{-}\text{-}\text{-} \,			%O	
		$\cdot\cdot$ \,						%I
		$\cdot$\text{-}$\cdot$ \,			%R
		$\cdot$}							%E
		
		\textbf{
		\text{-}$\cdot\cdot$ \,				%D
		$\cdot\cdot$\text{-} \,				%U
		\text{-}$\cdot$ \,\,\,\,\,\,		%N
		$\cdot$\text{-} \,					%A
		$\cdot$\text{-}$\cdot\cdot$ \, 		%L
		$\cdot$\text{-}$\cdot\cdot$ \, 		%L
		$\cdot$ \,							%E
		$\cdot$\text{-}$\cdot$}				%R
		
		\textbf{
		$\cdot$ \,							%E
		\text{-} \,\,\,\,\,\,				%T
		$\cdot$\text{-}$\cdot$	\,			%R
		$\cdot$ \,							%E
		\text{-} \,							%T
		\text{-}\text{-}\text{-} \,			%O
		$\cdot\cdot$\text{-} \,				%U
		$\cdot$\text{-}$\cdot$}				%R
		
        \vspace{2cm}
        
        \LARGE
        J. Aleksanderek
        
        K. Zdybal

        \vspace{8.5cm}
        
		\Large

 		October, 2016 - November, 2017
	\end{center}
\end{titlepage}

% EX-LIBRIS PAGE

\thispagestyle{empty}
\begin{center}
    
\vspace*{4cm}

\includegraphics[width = 80mm]{ex_libris_arduino.png}

\vspace*{2cm}

Copyright \textcopyright \, J. Aleksanderek, K. Zdybał, 2017

For more projects similar to this one

visit me on GitHub: @camillejr

To contact me personally drop me a line at:

\verb|kamilazdybal@gmail.com|

\vspace*{2cm}

\verb|Objectif Morse|

\verb|version 1.0|
\end{center}
\newpage

\setlength{\parskip}{1em}
\renewcommand{\baselinestretch}{1.0}

\thispagestyle{empty}
\begin{center}
    
\vspace*{2.5cm}

{\fontfamily{qbk}\selectfont
We would like to give special thanks to our friend Lama who shared her programming ideas with us when we were stuck in the project.

Thank you!
}
\vspace*{2cm}

\end{center}

\setlength{\parskip}{0em}
\renewcommand{\baselinestretch}{0.0}

\newpage

% PML PAGE

\thispagestyle{empty}
\begin{center}
    
\vspace*{2.5cm}

{\fontfamily{qbk}\selectfont
To the amazing members of the Penguin Mailing List.
}

\vspace*{3cm}

\includegraphics[width = 80mm]{PML.png}

\vspace*{1cm}

\small
{\fontfamily{qbk}\selectfont
\textit{<< A culture of "shared knowledge" is power}

\textit{still needs time and passion. >>}

\,\,\,

\textasciitilde Uncle Penguin

}

\vspace*{2cm}

\end{center}

\newpage

\setlength{\parindent}{0cm}
\clearpage

\tableofcontents

\setlength{\parskip}{1em}
\renewcommand{\baselinestretch}{1.0}

\newpage

\chapter{Introduction} \label{chap:intro}

\textbf{Welcome to the \textit{Objectif Morse} project.}

You will soon begin a journey through secret coded messages transmitted between powerful computers over tiny distances.

The first purpose of this document is to keep the record of the work that we did, the ideas and the solutions that we came up with and of the things that we have learned.

The second and more important purpose is to serve as a tutorial for you, if you ever feel like embarking on the same adventure as we did. Following this document you should be able to accomplish the same mission and maybe even extend it with your own ideas. This journey will increase your knowledge in C++, Linux, Arduino, electronics and, undoubtedly, French language. Either some basic understanding in all of these is required as a prerequisite, or a strong will to invest time and effort to learn many new things as you go.

This project is aimed for explorers and experimenters for whom it may seem difficult at first. We believe that the spirit of "learning by doing" is the most effective way to understand the difficult.

All the codes produced are not included in this document. You can download everything needed from our \href{https://github.com/camillejr/objectif_morse}{GitHub repository}.

Reach out to section \ref{sec:equip} to check if you have everything that you need!

It's time to present the mission objectives...

\section{Voici l'Objectif Morse}

You type a secret text message on a stationary computer into the terminal. This message is translated into Morse alphabet and the signal of dots and dashes is sent to the parallel port as high and low states. The parallel port pins are connected to a small circuit with an LED diode, which blinks accordingly to the message translation. No spies should be observing the diode. This message is received by a phototransistor, situated in the close proximity of the LED. The phototransistor passes the signal to the Arduino device. Arduino connected to a portable computer prints the received message in Morse on the Serial Monitor. The message is translated to regular text after reading the Arduino output and printed in the terminal of the portable computer. 

The message is received and the war is won.

\subsection{Choice for the project name}

The idea for this project was born while reading \textit{Les Aventures De Tintin}, comic books written by a belgian cartoonist Hergé, where messages transmitted in the Morse code are a common form of communication. 

The name \textit{Objectif Morse} is a reference to one of our favourite books in the series \textit{Objectif Lune} \cite{objectif_lune} (eng. \textit{Destination Moon}), and is hence a tribute to our initial inspiration.

\begin{figure}[H]
\centering\includegraphics[scale=0.1]{le_lotus_bleu}
\caption{Excerpt from \textit{Les Aventures de Tintin: Le Lotus Bleu} by Hergé \cite{le_lotus_bleu}}			
\label{fig:tintin}
\end{figure}

\section{Preparation} \label{sec:equip}

\subsection{Project phases}

This project is divided into two phases: \textbf{broadcasting} and \textbf{receiving}. 

These two phases don't require each other to get them working, however, the \textbf{receiving} phase needs a light trigger to obtain a signal. If you didn't build the  \textbf{broadcasting} phase you can use for example the light from a flashlight. Nevertheless, it's not recommended from the debugging point of view unless you are an expert in broadcasting Morse signals by hand.

The two phases are separated by a few centimetres air gap. What happens inside of the air gap shall remain a secret.

\subsection{Equipment used} 

Electronics:

\begin{enumerate}

\item LED diode
\item phototransistor
\item resistors: 330 Ohm, 10 000 Ohm
\item a few cables
\item at least one breadboard but it's best to have two
\item parallel port plug with soldered cables

\end{enumerate}

Computation:

\begin{enumerate}

\item Arduino Uno with a USB A-B cable
\item stationary computer with Linux
\item portable computer with Linux
\item of course you need some monitors and keyboards...

\end{enumerate}

Optional:

\begin{enumerate}

\item flashlight - increases the interactivity of this project

\end{enumerate}

\newpage

\subsection{Code used}

The \textit{Objectif Morse} project is coded in C++ language. We've used one of its famous features - Object Oriented Programming (OOP). If you're not a fan of OOP then to make your reading more interesting we give you a full permission to silently complain about our code.

This is a scheme of how the code should be distributed over devices:

\textbf{Stationary computer}

\begin{verbatim}
	broadcastMain.cpp
	morse.cpp
	morse.h
	sendToPort.cpp
	sendToPort.h
	makeFileB
\end{verbatim}

\textbf{Portable computer}

\begin{verbatim}
	receiveMain.cpp
	morse.cpp
	morse.h
	arduinoReceive.cpp
	arduinoReceive.h
	makeFileR
\end{verbatim}

\textbf{Arduino}

\begin{verbatim}
arduinoCode.ino
\end{verbatim}

In order to download our GitHub repository with all the necessary codes it's best to have \verb|git| installed on your computers. Then type in the command line:

\begin{snugshade}
\verb|git clone https://github.com/camillejr/objectif_morse.git|
\end{snugshade}

\newpage

\section{Morse alphabet}  \label{sec:morse}

The Morse alphabet characters are the following:

\begin{figure}[H]
\centering\includegraphics[width=10cm]{morse_alphabet}
\caption{Morse alphabet.}			
\label{fig:morse_alphabet}
\end{figure}

The basic unit of durations of signals in the Morse alphabet is what we call in our project \verb|dotTime|. This is the time that it takes to transmit the single dot signal. All the other durations are built from this unit and so we have:

\begin{enumerate}
\item the dot signal lasts \verb|dotTime|

\item the dash signal lasts \verb|3| $\times$ \verb|dotTime|

\item the space between signals within one character lasts \verb|dotTime|

\item the space between characters within one word lasts \verb|3| $\times$ \verb|dotTime|

\item the space between words lasts \verb|7| $\times$ \verb|dotTime|

\end{enumerate}

There is also a slash symbol used to represent the end of a sentence. When the transmission system is capable of sending this character, it would typically last \verb|7| $\times$ \verb|dotTime| or more.

\begin{figure}[H]
\centering\includegraphics[width=14.5cm]{morse_durations}
\caption{Durations in the Morse alphabet.}			
\label{fig:morse_durations}
\end{figure}

The Morse alphabet is scalable, which means that you can set the \verb|dotTime| to whatever time you need, and all the remaining intervals will simply become a corresponding multiple of that unit.

\section{Legal note}

First, it is possible that things won't work when you put the cables together. Second, it is possible that the code we produced contains bugs and might cause unexpected behaviours. Third, it is possible that certain favourable conditions\footnote{it is quite common among computers that the nearby presence of certain objects, or certain position with respect to certain constellations, or certain mysterious words in certain forgotten config files is causing things to work.} arose when we were working on this project and it might take some effort to make them reappear again.

If you have just said: \textit{"How awesome! I can't wait do deal with that!"}, then you're the right person in the right place. We wish you a lot of errors as you go because you're going to learn a lot from them. 

\newpage

\chapter{Broadcasting}

\includegraphics[width = 145mm]{working_2.jpg}

\verb|OBJECTIF_MORSE, PHASE: BROADCASTING -| the first phase of the \textit{Objectif Morse} project is to translate the secret message from regular text to Morse alphabet. This part comprises the message input into the terminal where the broadcasting code is running. The message is translated by the program and broadcasted on an LED diode connected to the parallel port output pin.



\newpage

\section{Code description}

The code for broadcasting the secret message in Morse consists of 5 files plus a makefile.

The code is split into user input/output interactive part (\verb|broadcastMain.cpp|), into functions that operate on messages (\verb|morse.cpp| and \verb|morse.h|) and into sending output to the parallel port (\verb|sendToPort.cpp| and \verb|sendToPort.h|).

The most important constituents of each file are presented in the graph below:

\begin{figure}[H]
\centering\includegraphics[width=14.5cm]{bCodeStructure}
\caption{Code structure for the \textbf{broadcasting} phase.}				
\label{fig:br_code}
\end{figure}

\subsection{Class \texttt{morse}}

We created a class called \verb|morse| that handles all the necessary variables and functions corresponding to translating from \verb|text > morse| and from \verb|morse > text|.

The definition of the class is presented in the listing below:

\begin{lstlisting}
class morse
{

	public:
	void inputMorse(std::string);
	void inputText(std::string);
	std::string outputMorse();
	std::string outputText();

	private:
	std::string morseMessage;
	std::string textMessage;
	static std::string code[];
	char translation(std::string);

};
\end{lstlisting}

\subsection{Functions and variables}

In this subsection we are going to take a closer look into what the functions and variables declared inside the \verb|morse| class do. This part is for you to get a quick overview and to help you glue things together in your head before you read the section \ref{sec:howB}, which describes the inner cogs much deeper.

\textbf{Functions}

\verb|morse::inputMorse()| - takes a string written in Morse alphabet as an input. Ideally, the input string should only consist of the following characters:

\begin{enumerate}
\item dot \verb|"."|

\item dash \verb|"-"|

\item space \verb|" "|

\item slash \verb|"/"|
\end{enumerate}

If the user inputs characters other then the listed above, they will be treated as unknowns in the message.

\verb|morse::inputText()| - takes a string written in alphanumeric characters as an input. The input string should only consist of:

\begin{enumerate}
\item letters \verb|A-Z| (\verb|a-z|)
\item numbers \verb|0-9|
\item space \verb|" "|
\item full stop \verb|"."|
\item comma \verb|","|
\end{enumerate}

If the user inputs characters other then the listed above, they will be ignored in the message.

\verb|morse::outputMorse()| - function that returns the ready string consisting of message written in Morse alphabet.

\verb|morse::outputText()| - function that returns the ready string consisting of the message written in alphanumeric characters.

\verb|morse::translation()| - translates a series of dots and dashes from the Morse message to the ASCII sequence.

\textbf{Variables}

\verb|morse::morseMessage| - contains message written in Morse alphabet.

\verb|morse::textMessage| - contains message written in alphanumeric characters.

\verb|morse::code| - an array of strings that create the Morse alphabet table. A closer description of this array is given in section \ref{sec:asciitomorse}.

\subsection{Main}

The "main" of the broadcasting phase is included in the file \verb|broadcastMain.cpp|. This is where a lot of messing around can be performed, because this code is just calling our already preciously prepared pieces. If you don't like our implementation of the user interface\footnote{brave words.} in the \textit{Objectif Morse} project, you have a lot of freedom to play with this file.

There is one interesting behaviour that can be controlled from the \verb|main| function - speed of the transmission, or more precisely - the duration of one dot signal (see \ref{sec:morse}) in the Morse alphabet. This duration in micro seconds is initially set to 25000 (0.25 second) when calling \verb|sendToPort| function: 

\begin{lstlisting}
sendToPort(secretMessage.outputMorse(), 1, 25000);
\end{lstlisting}

but can be adjusted to your needs.

\subsection{Fire it up with makefile}

To compile the code on your computer you can use the makefile \verb|makeFileB|.

Simply teleport yourself to the place where the 5 files are placed and at that location run from the command line:

\begin{snugshade}
\verb|make -f makeFileB|
\end{snugshade}

This will result in the creation of one more file, a binary called \verb|broadcast|.

To fire up the whole code structure (in fact, to primarily run the \verb|main| function from \verb|broadcastMain.cpp|) type in the command line:

\begin{snugshade}
\verb|./broadcast|
\end{snugshade}


In certain cases you may need to run the binary as \verb|root|:

\begin{snugshade}
\verb|sudo ./broadcast|
\end{snugshade}

\subsection{Test run}

One thing that you can do right now is to ask the program to translate something for you! After the code is started you should see:

\begin{snugshade}
\begin{verbatim}
Select translation:
1) Text to Morse
2) Morse to text
\end{verbatim}
\end{snugshade}

Type either 1 or 2 to select an option and then input the message to translate!

As long as the electronics isn't connected to the parallel port, when you select 1, nothing more spectacular should happen.

Any errors in trying to send the message to the parallel port will result in an error message at the end of the translation:

\begin{snugshade}
\begin{verbatim}
Select translation:
1) Text to Morse
2) Morse to text
1
Type text message:
Hello world
You've typed: 
Hello world
Morse code: 
.... . .-.. .-.. ---   .-- --- .-. .-.. -.. 
Error sending message to parallel port.
\end{verbatim}
\end{snugshade}

The functionality to translate from Morse to text has been added mostly for fun here. When you input message directly in Morse alphabet it won't be transmitted, this is because our initial objective was to input secret message in regular text. Feel free to translate the subtitle from the front page of this document!

\section{How does it work} \label{sec:howB}

This section is diving a little deeper into an explanation of the ideas behind the \textbf{broadcasting} phase. It also tells you how to set up the electronics part and hence we hope that things will get much more fun right now!

\subsection{Parallel port connection} \label{sec:parportcon}

In this section we describe how to connect to the parallel port (parport\footnote{if you wish to sound more technical.}) and how to build a simple circuit with an LED diode. Notice that not every computer has got a parallel port. Usually, a portable computer will not be equipped with a parport, so try to get one old-school stationary computer like we did! The parallel port is big and pink like this one:

\begin{figure}[H]
\centering\includegraphics[width=8cm]{par_port}
\caption{Parallel port pins: DATA and GND.}				
\label{fig:par_port}
\end{figure}

You should be mostly interested in two sets of pins here - data pins (DATA) and ground pins (GND). There's eight data pins, marked in red in the picture above. They will serve as our (+) and they are the ones, who's high and low states can be controlled from the program. There's also eight ground pins, marked in black in the picture and they serve as our (-).

It doesn't really matter which ground pin you connect to. It also doesn't matter which data pin you connect to but you should adjust the value in the place of \verb|yourNumber| in the file \verb|sendToPort.cpp|:

\begin{snugshade}
\verb|ioperm(base, yourNumber, 1)|
\end{snugshade}

By this value you specify up to which DATA pin you give the permission to connect to. For example, if you set \verb|yourNumber = 3|, you will be allowed to use pins: first, second and third. Since we only needed one DATA pin to connect to, we've given ourselves permission to access just the first one, so this value is 1 by default. To read more about \verb|ioperm| (short from input/output permission) check out this page \cite{ioperm}.

You should also be equipped with a parallel port plug. The best idea is to solder ground and data cables so that they stick firmly to the plug. Here's the picture of our plug, connected to the cables:

\begin{figure}[H]
\centering\includegraphics[width=8cm]{parport_plug}
\caption{Parallel port plug.}				
\label{fig:parport_plug}
\end{figure}

Remember that you only need two cables - one ground and one data. You don't have to worry about other colourful cables in the picture above.

The final thing to do is to build the rest of the circuit connected to the plug, which is very simple! It only consist of an LED diode and a 330$\Omega$ resistor.

\begin{figure}[H]
\centering\includegraphics[width=8cm]{broadcast_circuit}
\caption{Electronic circuit for broadcasting.}				
\label{fig:broadcast_circuit}
\end{figure}

\subsection{Alphanumeric to Morse} \label{sec:asciitomorse}

Probably the most important (and interesting) part of the \textit{Objectif Morse} is the introduction of the Morse alphabet in the code. Each letter \verb|A-Z| (\verb|a-z|) and each digit \verb|0-9| has got its representation in the Morse alphabet. Notice also, that the Morse alphabet is not case sensitive and both lower-case and upper-case letters translate to the same Morse character. So how can the sequence of dots and dashes be implemented in C++?

The definition of the Morse alphabet is present in the file \verb|morse.cpp| inside the variable called \verb|morse::code|. This is an array of strings that contains all Morse alphabet characters. Its graphical representation is shown below:

\begin{figure}[H]
\centering\includegraphics[scale=0.1]{morse--code}
\caption{Morse code array.}				
\label{fig:morse_code_array}
\end{figure}

Every ASCII character is assigned a number, which inside the C++ language can be retrieved by casting the character into an integer. This is done by the following line inside the function \verb|morse::inputText()|: 

\begin{lstlisting}
num = (int)textMessage[n];
\end{lstlisting}

For example, for a \verb|textMessage| character equal to "\verb|f|" the parameter \verb|num| will be equal to 102.

For the characters used in this project we have the following ASCII numerations:

\begin{enumerate}

\item upper-case letters \verb|A-Z| : 65 - 90

\item lower-case letters \verb|a-z| : 97 - 122

\item digits \verb|0-9| : 48 - 57

\item space \verb|" "| : 32

\item full stop \verb|"."| : 46

\item comma \verb|","| : 44

\end{enumerate}


We have then decided to map every legal alphanumeric ASCII character into the created array. This means that each alphanumeric character number gets the number of its index inside the \verb|morse::code| array. This is achieved by subtracting certain number from the ASCII numeration. The graphical representation of this mapping is presented below:

\begin{figure}[H]
\centering\includegraphics[scale=0.1]{morse_code_map}
\caption{Mapping alphanumeric characters to the morse code array elements.}				
\label{fig:morse_code_map}
\end{figure}

Inside the code we have therefore:

\begin{lstlisting}
if (num > 64 && num < 91) morseMessage += code[num - 65];
	else if (num > 47 && num < 58) morseMessage += code[num - 22];
	else if (num > 96 && num < 123) morseMessage += code[num - 97];
\end{lstlisting}

Using our previous example, the character "\verb|f|" will result in \verb|num| = 102 and since this number is between 96 and 123 (lower-case character), the number subtracted will be 97. This will altogether result in the position with index 5 in the \verb|morse::code| array, which corresponds to a string "$\cdot\cdot$\text{-}$\cdot$". 

This string will be added (\verb|+=|) to the message translation variable \verb|morseMessage|.

With each run of the \verb|for| loop in the \verb|morse::inputText()| function, the coded message will be appended by the next Morse code character.

Notice that there is also an \verb|else| statement, which takes care of other non-alphanumeric characters which the user can type. The legal non-alphanumeric characters includes a full stop, a space and a comma. Every other character is by default replaced with a space in the translation.

\newpage

\begin{lstlisting}
else
{
  switch (num)
  {
    case 46:
    {
      morseMessage += "/";
      break;
    }
    case 32:
    {
      morseMessage += " ";
      break;
    }
    case 44:
    {
      morseMessage += "/";
      break;
    }
    default:
    {
      morseMessage += " ";
      break;
    }
  }
}
\end{lstlisting}


\subsection{Morse to alphanumeric}

The translation from the Morse alphabet to the regular text is taken care of by two \verb|morse| class functions: \verb|morse::inputMorse()| and \verb|morse::translation()|.

The function \verb|morse::translation()| contains a simple reverse process to what the \verb|if()| in the function \verb|morse::inputText()| was doing. So let's take a closer look:

\begin{lstlisting}
if (!tempString.empty())
{
	for (int k = 0 ; k < 36 ; ++k)
		{
			if (tempString == code[k])
			{
				if (k > 25)
				{
					return (char)(k + 22);
				}
				else	
				{
					return (char)(k + 97);
				}
				break;
			}
			if (k == 35)	
			{
				return "_";
			}
		}
}
\end{lstlisting}

This \verb|if()| statement takes one Morse character as an input. An example \verb|tempString| might for instance be equal to "$\cdot\cdot$\text{-}$\cdot$". Then it runs through the \verb|morse::code| array and checks if the character matches any of the entries inside the array. If it does, then it's going to be either a letter or a number written in the Morse code.

As previously described, all letters have indices 0-25 and all numbers have indices 26-35. Instead of subtracting a number we now have to add it to the index in the \verb|morse::code| array to obtain the corresponding ASCII numeration. The returned value is an integer casted to a character, either:

\begin{lstlisting}
return (char)(k + 22);
\end{lstlisting}

for numbers, or:

\begin{lstlisting}
return (char)(k + 97);
\end{lstlisting}

for letters.

This returned value is the translation of one character from the secret message written in Morse. For example, if the \verb|tempString| was equal to "$\cdot\cdot$\text{-}$\cdot$", the index in the array \verb|morse::code| is \verb|k = 5|. Since \verb|k| is less than 25, we know that it's a letter in ASCII and that we have to add 97 to match the ASCII numeration. 

\begin{lstlisting}
return (char)(5 + 97);
\end{lstlisting}

Turning the number 102 to character gives us the letter \verb|"f"|.

The \verb|while()| in the function  \verb|morse::inputMorse()| is making an initial preparation of a Morse character - it's building the content of the variable \verb|tempString|. You can think of the job done by the \verb|while()| as "slicing" the secret message to chunks consisting of single Morse characters.

This is a piece of that \verb|while()|, without one final \verb|case|, which we'll describe next:

\begin{lstlisting}
while (n < len)
{
	tempChar = morseCode[n];
	switch (tempChar)
	{
		case ".":
		{
			tempString += ".";
			++n;
			break;
		}
		case "-":
		{
			tempString += "-";
			++n;
			break;
		}
		case "/":
		{
			addDot = true;
			++n;
		}
		default:
		{
			textMessage += "*";
			break;
		}
	}
}
\end{lstlisting}

The drawing below shows how we define \verb|tempChar|, \verb|tempString| and \verb|textMessage|. Each blue box would be one \verb|tempChar| that the \verb|while()| is currently looking at. It would contain either one Morse signal (one dot or one dash), or a space or, if the sentence has ended, the slash symbol.

\begin{figure}[H]
\centering\includegraphics[width=14.5cm]{temp_string}
\caption{How \texttt{tempChar}, \texttt{tempString} and \texttt{textMessage} are defined.}
\label{fig:temp_char}
\end{figure}

You're maybe wondering what is this variable \verb|addDot| all about. It simply states whether a full stop "." should be appended to the message translation. Whenever slash is present in the Morse message, it means that a sentence has ended and in the message written in regular text a full stop should be placed at the end of a sentence. So the flag \verb|addDot| is raised to \verb|true|, saying: \textit{Yup! We have the end of the sentence!} 

May we now bring your attention to this final \verb|case|. The interesting thing happens when the \verb|while()| encounters a space in the message \verb|" "|. 

\begin{lstlisting}
case " ":
{
  textMessage += translation(tempString);

  tempString.clear();

  if (addDot == true)
  {
    textMessage += ". ";
    addDot = false;
  }

  int spaceCount = 0;

  while (morseCode[n] == " " && n < len)
  {
    ++spaceCount;
    ++n;
  }

  if (spaceCount < 3)
  {
    break;
  }

  else
  {
    textMessage += " ";
    break;
  }
}
\end{lstlisting}

First of all, this means that one full Morse character has finished and it can be translated, hence the first thing to do is:

\begin{lstlisting}
textMessage += translation(tempString);
\end{lstlisting}

This line is saying: \textit{Hey! That's the end of a character! Dear function}
\texttt{morse::translation()}\textit{, would you please translate it for me?} And then the result of the translation gets appended to the variable \verb|textMessage|.

Next, we have to find out what is the reason for why the character has ended. Let's look at the message as the user might input it into the terminal:

\begin{snugshade}
\verb|--- -.   -.--   ...- .-/|
\end{snugshade}


So the reason might be twofold: either it's a space between Morse characters within the same word, or it's a space which separates two words. This final \verb|case| is counting how many spaces are there after the first encountered, and then it's classifying the reason. We have given it some flexibility as well, so you can see that when the total number of clustered spaces is less than or equal to three, we're doing nothing and just treating this as a space between Morse characters. If it's any larger than 3 we're interpreting that as a space between words and in the message translation to regular text we have to add a space as well.

\begin{snugshade}
\verb|on y va.|
\end{snugshade}

\newpage

\subsection{Sending the output to the parallel port}

The code responsible for sending the message as high and low states to the parallel port is \verb|sendToPort.cpp|.

There is only one function defined in this file and it is called \texttt{sendToPort()}. It takes as inputs two variables: the message to be broadcasted and the duration \texttt{dotTime} which defines the speed of the transmission.

But before we jump into this function's body, let's take a closer look at the declarations section. You can see the mysterious line here:

\begin{lstlisting}
#define base 0x378
\end{lstlisting}

The hex number \texttt{0x378} defines a register address in the memory. This memory area is 8-bits long and each of its bits is directly linked to each of the 8 DATA pins on the parport. The low or high state at any bit of this area (represented by either 0 or 1) is going to be the same at the parport pin linked to this bit.

We can then tell the bit to turn its value to 1 and the state of the corresponding DATA pin will become high - meaning that if an LED diode was connected to this pin it would light up.

So that's how we're going to transmit the message to the parallel port - by simply writing the correct values to this special memory place.

If you're curious about the \texttt{\#define} instruction we encourage you to read more about macros\footnote{and you will most likely read that they are best to be avoided!} in C++. All that is important to know for now is that this line is saying: whenever you see "\texttt{base}" written in the code, replace it with the value \texttt{0x378}. It's much like an alias and a somewhat more fancy way of stating that \texttt{base = 0x378}.

Now let's come back to the \texttt{sendToPort()} function and see what's coded inside!

First, you'll see the \texttt{if()} statement with the \texttt{ioperm()} function that you've already heard about in the subsection \ref{sec:parportcon}. This is just a check in case something goes wrong with obtaining permissions to access the parallel port.

Then comes the \texttt{for()} loop which iterates over every character in the secret message \texttt{stringToSend} and then classifies what it is using \texttt{switch()}.

\begin{lstlisting}
switch (stringChar)
{
  case ".":
  {
    outb(1, base);
    usleep(dotTime);
    outb(0, base);
    usleep(dotTime);
    break;
  }
  case "-":
  {
    outb(1, base);
    usleep(3*dotTime);
    outb(0, base);
    usleep(dotTime);
    break;
  }
  case " ":
  {
    outb(0, base);
    usleep(2*dotTime);
    if (stringToSend[i+1] == " ")
    {
      ++i;
      if (stringToSend[i+1] == " ")
      {
        ++i;
        usleep(4*dotTime);
      }
    }
    break;
  }
  case "/":
  {
    usleep(6*dotTime);
    break;
  }
}
\end{lstlisting}

There are two helpful functions that we're using. The first one is the function \texttt{outb()}, used here to write low (0) or high (1) state into the register address \texttt{0x378}. The second one, function \texttt{usleep()}, is simply telling the program to "\textit{wait and do nothing}" for a period of time specified as its argument; we're going to call it "sleep".

Analysing the first two cases you can probably see right away what is happening: we write (1) to the register, which lights up the diode and then we sleep for a certain period of time which corresponds to the Morse signal that we're broadcasting, e.g. for \verb|dotTime| when the signal is a dot or for \verb|3| $\times$ \verb|dotTime| when the signal is a dash. While we sleep the diode is turned on all that time. After that we turn the diode off by writing a low state (0) into the register.

Notice that at the end of broadcasting a dot or a dash there is always one more sleep in the "off" state for the duration of \verb|dotTime|. This is done in order to transmit the space between Morse signals - which lasts one \verb|dotTime|.

Again the most interesting thing happens when the current character \texttt{stringChar} is a space " ". First of all, this means that one full Morse character has ended. And this would mean that it is either a space between characters within one word or a space between words. In any case, we can already sleep for another \verb|2| $\times$ \verb|dotTime|.\footnote{observe that we already sleep one \texttt{dotTime} after every Morse signal, so the additional \texttt{2} $\times$ \texttt{dotTime} will add up to sleeping \texttt{3} $\times$ \texttt{dotTime} if this is the end of the Morse character.} 

Next, we check if there are still more spaces after the first encountered. If there is a space still ahead, we simply move on to the next character in the \texttt{stringChar} and we check again (in the second \texttt{if()} statement) if there is one more space ahead. This already means that there are three consecutive spaces which signifies the space between words and we have to sleep for another \verb|4| $\times$ \verb|dotTime|\footnote{so that altogether we have slept for \texttt{7} $\times$ \texttt{dotTime} here.}

Finally, in the last \texttt{case}, where the character encountered is "/" we simply sleep for \verb|6| $\times$ \verb|dotTime|\footnote{again, altogether we have slept for \texttt{7} $\times$ \texttt{dotTime} here.} and this would be the end of a sentence.

Uffff. We realize that keeping track of all these durations can be a real pain in the neck! This was a source of a lot of mistakes in our initial versions of the code. For example we forgot that we were already sleeping one \verb|dotTime| after every Morse signal and at first we made the code sleep for too long after every Morse character. So don't feel discouraged if you didn't follow that explanation. Take as much time as you need to digest what is happening here.

\subsubsection{Function callout}

An example of the function callout could be the one from \texttt{broadcastMain.cpp}:

\begin{lstlisting}
sendToPort(secretMessage.outputMorse(), 25000);
\end{lstlisting}

where we give as an input the message to broadcast: \texttt{secretMessage.outputMorse()} and the time duration \texttt{dotTime = 25000}ms.

\newpage

\chapter{Receiving}

\includegraphics[width = 145mm]{working_1.jpg}

\verb|OBJECTIF_MORSE, PHASE: RECEIVING -| the second phase of the \textit{Objectif Morse} project is to capture the secret message coming from far away in Morse alphabet and decode it to back regular text. This part begins where the phototransistor connected to Arduino receives the light trigger and Arduino passes in on to the receiving code running on a different machine for further translation and output.

\newpage

\section{Code description}

The code for receiving phase consists of 5 files plus a makefile. 

The broadcasting and receiving phase share the same \verb|morse.cpp| file responsible for translation of messages. Additionally, there is a set of functions that parse the Arduino output (\verb|arduinoReceive.cpp|, \verb|ArduinoReceive.h|) and the output part (\verb|receiveMain.cpp|, \verb|receiveMain.h|) responsible for printing the result of the message translation in the command line.

The code structure is presented in the graph below:

\begin{figure}[H]
\centering\includegraphics[width=14.5cm]{rCodeStructure}
\caption{Code structure for \textbf{receiving} phase.}	
\label{fig:re_code}
\end{figure}


\subsection{Class \texttt{arduino}}

For handling the output received from Arduino we created a class called \verb|arduino|:

\begin{lstlisting}
class arduino
{

	public:
	void start();
	void stop();
	void read();
	std::string output();

	private:
	FILE* arduinoFile;
	std::vector<int> durations;
	
};
\end{lstlisting}

\subsection{Functions and variables}

\subsubsection{Functions}

\verb|arduino::start()| - function that opens the Arduino output file for reading.

\verb|arduino::stop()| - function that closes the Arduino output file.

\verb|arduino::read()| - function that reads the output from the Arduino output file.

\verb|arduino::output()| - function that translates the Arduino output to a string written in the Morse code.

\subsubsection{Variables}

\verb|arduino::arduinoFile| - contains a pointer to the Arduino output file.

\verb|arduino::durations| - a vector of integers storing a stream of Morse signals.

\subsection{Main}

The "main" of the \textbf{receiving} phase is included in the file \verb|receiveMain.cpp|. 

\subsection{Fire it up with makefile}

The code is compiled in an analogous way to the \textbf{broadcasting} phase. Once you have all 5 files in one place run from the command line:

\begin{snugshade}
\verb|make -f makeFileR|
\end{snugshade}

A new binary file called \verb|receive| will be produced.

To run the \textbf{receiving} phase type in the command line:

\begin{snugshade}
\verb|./receive|
\end{snugshade}

If this doesn't work, you might need to run the binary as \verb|root|:

\begin{snugshade}
\verb|sudo ./receive|
\end{snugshade}

And the code should be up and running!

\subsection{Test run}

Whether you've already built the \textbf{broadcasting} phase or not, you can run the binary \verb|receive| and see for yourself what the \textit{Objectif Morse} is capable of!

When the code is started you will see the modest:

\begin{snugshade}
\verb|Input time:|
\end{snugshade}

You should type the time in seconds during which the setup will "listen" to the incomming message.

If you have a flashlight at hand you may want to play a little with broadcasting Morse signals by hand. Just type for example 30 seconds and hit Enter:

\begin{snugshade}
\begin{verbatim}
Input time:
30
\end{verbatim}
\end{snugshade}


\section{How does it work}

\subsection{Arduino connection}

The picture below describes how to build the electronic circuit for the \textbf{receiving} phase. It consists of a phototransistor and a 10 000$\Omega$ resistor. \textbf{Always double-check the circuit that gets connected to Arduino} because the mistakes may sometimes be sad for your little Italian device. It's a good habit to first upload the code to Arduino (only connecting it to a USB A-B cable) then disconnect the Arduino from the USB and assemble the circuit in a powered-off mode.

We use the analog pin A0, as well as the 5V pin to serve as our (+) and the GND pin to serve as (-).

\begin{figure}[H]
\centering\includegraphics[width=8cm]{receive_circuit}
\caption{Electronic circuit for the receiving phase.}				
\label{fig:receiving_circuit}
\end{figure}




\subsection{Arduino code}

In this part we describe the contents of the Arduino code \verb|arduinoCode.ino|. This code is written in C language and should be uploaded to your Arduino device. We recommend downloading Arduino IDE for Linux - a neat little program in which you can easily verify and upload Arduino codes. It also comes with a library of examples that could be useful in your future projects.

\subsubsection{Arduino's job}

The aim of the Arduino code is to identify the signal as Low (\verb|L|) or High (\verb|H|) and to measure the time duration in \textit{ms} of that state.

One of the sample Arduino outputs can be:

\begin{snugshade}
\begin{verbatim}
L 200
H 200
L 600
\end{verbatim}
\end{snugshade}

Which has the interpretation as follows: Low state lasted 200 \textit{ms}, then High state lasted 200 \textit{ms}, then Low state lasted 600 \textit{ms}, and so on...




\subsubsection{Variables}

Variables used in the code:

\verb|analogInPin| - specifies the analog pin that we connect to, in our case it's A0.

\verb|sensorValue| - the value of voltage read using \verb|analogRead()| function. This value describes the luminosity as seen directly by the phototransistor. It's a number between 0 and 1023.

\verb|sensorMean| - the mean luminosity, assuming that the LED diode is not lit up. It is calculated in the calibration part of the code.

\verb|sensorThres| - the lower threshold of the High state. Any value higher then this will be considered as a High state. It is calculated in the calibration part of the code.

\verb|prevSignal| - a boolean describing the state from which the change has just occured. It is \verb|true| when the previous state was High and \verb|false| when the previous state was Low.

\verb|timeDuration| - the total time of the last Low or High state.

\verb|timePrev| - the time in \textit{ms} at which the change from Low to High or from High to Low occured, measured from the beginning of the program operation.

In the graph below we present in a closer detail how the Low and High state is interpreted by the Arduino code. Anything that is higher then \verb|sensorThres| is interpreted as a High state. Anything that is 10 from \verb|sensorMean| (either way) is interpreted as a Low state. There are two gaps where the signal is not interpreted as either High or Low. The explanation for why we've made it that way is present under \textbf{Blackout zone explanation} at the end of this subsection.

\begin{figure}[H]
\centering\includegraphics[width=14.5cm]{arduinocode}
\caption{Interpretation of Low and High states using defined variables.}				
\label{fig:arduino_code}
\end{figure}



\subsubsection{Calibration}

The aim of the calibration is to measure the mean luminosity around the phototransistor and to use this information for further processing of the luminosity that comes from the LED diode itself. This mean luminosity will be present everytime we have a Low state in our signal - interpreted as "darkness".

The need to do this comes from the fact that we can send our coded messages during sunny or gloomy day or during the night, and we want the Arduino to correctly interpret what part of the luminosity comes from the general brightness of the surroundings and what part are the changes due to the LED diode.

The aim of the calibration is to obtain the value \verb|sensorMean|. This is performed by reading 10 values of \verb|sensorValue| in 100 \textit{ms} time steps and calculating their arithmetic average.

\subsubsection{Identifying the voltage changes}

Inside the \verb|loop()| function, the \verb|sensorValue| is read at the beginning and then if certain conditions are met, we have either signal changing from Low to High or changing from High to Low.

The signal is changing from Low to High when the voltage read is greater than the \verb|sensorThres| and when the previous signal was Low (when the \verb|prevSignal| is set to false). This condition is comprised in the following \verb|if()| statement:

\begin{lstlisting}
if (sensorValue > sensorThres && !prevSignal)
\end{lstlisting}

\begin{figure}[H]
\centering\includegraphics[width=8cm]{lowtohigh}
\caption{Signal changing from Low to High. (Red dots represent the \texttt{sensorValue} measurements.)}				
\label{fig:arduino_code}
\end{figure}

The signal is changing from High to Low when the voltage read is within 10 from the \verb|sensorMean| value and when the previous signal was High (when the \verb|prevSignal| is set to true). This condition is comprised in the following \verb|if()| statement:

\begin{lstlisting}
if (sensorValue - sensorMean < 10 && prevSignal)
\end{lstlisting}

\begin{figure}[H]
\centering\includegraphics[width=8cm]{hightolow}
\caption{Signal changing from High to Low. (Red dots represent the \texttt{sensorValue} measurements.)}				
\label{fig:arduino_code}
\end{figure}

\subsubsection{Measuring the time durations}

Each time we enter one of the two \verb|if()| statements, the time of the last finished state (High or Low) must be identified, measured and printed on the Serial Monitor.

Additionally, a flag \verb|prevSignal| is always changed to describe the currently entered state.

For the purpose of measuring the time durations we use the built-in Arduino function \verb|millis()|. This function measures the time in \textit{ms} that has passed from the beginning of the operation of the program. It can therefore be viewed as an absolute time. It increases while the Arduino operates and is only set back to zero, when the Arduino is reset.

The variable \verb|timeDuration|, which we are interested in, is therefore measured as a difference between the current absolute time and the time at which the last change occurred. Looking at the Fig. \ref{fig:timedur}, the red dot represents the first voltage measurement made after the signal has changed from High to Low. The time of the last High state has to be measured and it is equal to \verb|millis() - timePrev|, where the 
\textcolor{cadr}{\texttt{timePrev}} in this case is the time at which the High state has begun.

\begin{figure}[H]
\centering\includegraphics[width=14.5cm]{timedurations}
\caption{Measuring the time durations.}				
\label{fig:timedur}
\end{figure}

The identification of the last finished state as High or Low is made by entering the correct \verb|if()| condition, and then accordingly we print on the Serial Monitor either \verb|"H"| or \verb|"L"|, followed by the current value of the variable \verb|timeDuration|.

The corresponding flag needs to be raised. If we entered the High state, the \verb|prevSignal| has to be set to true and if we entered the Low state, the \verb|prevSignal| has to be set to false.

Finally, it should be noted that entering the \verb|if()| conditions happen only at changes between Low and High states. Outside of this changes, the \verb|loop()| function simply keeps measuring the \verb|sensorValue|.

\subsubsection{Blackout zone explanation}

Not everything can be perfect. Imagine a situation when the currently measured signal was High and while it was supposed to turn back to Low some additional light appeared in the surroundings that wasn't coming from the LED. If the boundary between High and Low states were touching, the graph of the measured \texttt{sensorValue} might for a short period of time become this:

\begin{figure}[H]
\centering\includegraphics[width=14.5cm]{blackoutZone.png}
\caption{Signal corrupted due to light coming from different sources.}				
\label{fig:blackoutzone}
\end{figure}

and give a nonsense measurements of short oscillations between High and Low state.

In order to protect the \textbf{receiving} phase we decided that we won't make the boundary between High and Low state touch, therefore making a relatively big separation between what is interpreted as High or Low state. In that case even if the oscillation happens, the measurements inside the blackout zone will be ignored by Arduino.

\begin{figure}[H]
\centering\includegraphics[width=14.5cm]{blackoutZoneIgnored.png}
\caption{The signal inside the blackout zone is ignored.}				
\label{fig:blackoutzoneignored}
\end{figure}

\subsection{Interpreting the Arduino output}

The output from the Arduino device is being stored in a special file under Linux directory:

\begin{snugshade}
\begin{verbatim}
/dev/ttyACM0
\end{verbatim}
\end{snugshade}

As long as Arduino is measuring, we are receiving the outputs one by one in the form like this:

\begin{snugshade}
\begin{verbatim}
L 200
\end{verbatim}
\end{snugshade}

\begin{snugshade}
\begin{verbatim}
H 200
\end{verbatim}
\end{snugshade}

\begin{snugshade}
\begin{verbatim}
L 600
\end{verbatim}
\end{snugshade}

While this outputs are coming we're going to access the file \texttt{/dev/ttyACM0} to capture each one of them and our code is going to store and make sense out of that data.

The translation of the Arduino output to the actual stream of Morse signals ready to be interpreted by the \texttt{morse.cpp} code is handled by the file \texttt{arduinoReceive.cpp} (that's a lot of translations, n'est pas?).

\subsubsection{Vector \texttt{durations}}

The goal of the \texttt{arduino::read()} function is to build a vector called \texttt{durations} in which at even indices are the durations of High signals (in \textit{ms}) and at odd indices are the durations of Low signals (in \textit{ms} as well).

For instance, the Arduino output like this one:

\begin{snugshade}
\begin{verbatim}
L 200
H 200
L 600
.
.
.
\end{verbatim}
\end{snugshade}

will become a stream of consecutive durations like this:

\begin{snugshade}
\begin{verbatim}
{0, 200, 200, 600, ...}
\end{verbatim}
\end{snugshade}

Since this example output started with the Low signal we cannot place in at the first available index (index 0), because the Low signals are placed at odd indices. In that case a duration of 0ms is placed first (at index 0) and then the proper Low signal duration at the next index 1. These "zero" durations are simply placeholders and they do not spoil the received message.

\begin{figure}[H]
\centering\includegraphics[width=10.5cm]{durations.png}
\caption{Constructing the vector \texttt{durations}.}				
\label{fig:timedur}
\end{figure}

Correct placement inside the vector \texttt{durations} is taken care by the following two conditions:

\begin{lstlisting}
if (durations.size()%2 == 0)
{
	switch(tempChar)
	{
		case "H":
		{
			durations.push_back(tempInt);
			break;
		}
		case "L":
		{
			durations.push_back(0);
			durations.push_back(tempInt);
			break;
		}
		default:
		{
			std::cout << "Transmission error.";
			break;
		}
	}
}
\end{lstlisting}

The first one is entered when the size of the vector is divisible by 2, meaning the index at which we'll be appending the next duration is also divisible by 2. When the current output from Arduino is a High signal ("H") we simply append to the vector because high signals can be placed at even indices. If it happens that the current output from Arduino (for whatever reason) is Low ("L"), we're going to first append the "zero" placeholder and then the duration of the incoming Low signal.


\begin{lstlisting}
else
{
	switch(tempChar)
	{
		case "L":
		{
			durations.push_back(tempInt);
			break;
		}
		case "H":
		{
			durations.push_back(0);
			durations.push_back(tempInt);
			break;
		}
		default:
		{
			std::cout << "Transmission error.";
			break;
		}
	}
}
\end{lstlisting}

The second condition is handling everything else, so the cases when the current appending index is odd. The situation is now reversed - if the incoming Arduino signal is Low ("L"), we simply append it to the vector and if the incoming signal is High ("H") we first place the "zero" placeholder and then the proper signal duration.

\subsubsection{The matter of trust}

The final function in the \texttt{arduinoReceive.cpp} is \texttt{arduino::output()}. It's main role is to turn the Arduino output into a string of Morse alphabet characters, namely turn something like this:

\begin{snugshade}
\begin{verbatim}
H 600
L 200
H 200
L 200
H 600
L 200
H 600
L 600
H 600
L 200
H 600
L 200
H 600
L 600
\end{verbatim}
\end{snugshade}

into a string like this:

\begin{snugshade}
\begin{verbatim}
"-.-- ---"
\end{verbatim}
\end{snugshade}

Once we have the string written in Morse we can pass it on to the function \texttt{morse::outputText()} which will take care of the translation to text!

First of all, we have to know what does a duration of - say \texttt{H 200} mean - is 200ms a dot or a dash? Being a human, you probably didn't have problems seeing which High signals were dots and which were dashes in the message above. To find out you looked at the whole context to see what is the lowest and what is the highest duration of the High signal.

Our program will have to do something similar - it will look at the whole message first to figure out which durations correspond to the dot and dash.\footnote{Notice that since we allow the message to be transmitted at different speeds (chosen by the user), we cannot make for example the \texttt{dotTime} duration fixed in the code.}

Now that the Arduino output is nicely sorted inside the vector \texttt{durations}, we're going to make use of knowing where the High and Low signals sit in that vector.  

Because the message might, in a particular case, contain much more dots than dashes (or in reverse), we've decided that we will base our calculation of durations on the most frequently occurring one of the two.\footnote{There are of course some extreme cases where the whole message broadcasted is the letter "e" or "t". We have no way of knowing what was the transmitted character. If this is the message that you would like to transmit, we encourage you to additionally write something like "Kisses and hugs.".} It's simply the matter of trust, since the Arduino might measure them with a certain error.

First we calculate what is the average duration of a high signal \texttt{averageHigh}:

\begin{lstlisting}
for (i = 0 ; i < durSize ; i += 2)
{
	if (durations[i] != 0)
	{
		++numNonZero;
		averageHigh += durations[i];
	}
}

averageHigh /= numNonZero;
\end{lstlisting}

This for loop goes over every second element of the vector \texttt{durations} starting at the zero$^{th}$ index, knowing that the High states are placed at even indices. We only count the non-zero durations, so if any "zero" placeholders were included in the vector they will be ignored.

Based on that we're measuring how many dots and how many dashes there are in the message and compute the average duration of a dot and a dash. We assume that any High state that lasted less than the \texttt{averageHigh} is a dot and any that lasted longer is a dash.

\begin{lstlisting}
for (i = 0 ; i < durSize ; i += 2)
{
     	if(durations[i] != 0)
	{
		if (durations[i] < averageHigh)
		{
			++ numDot;
			averageDot += durations[i];
		}
		else
		{
			++ numDash;
			averageDash += durations[i];
		}
	}
}
\end{lstlisting}

Additionally, this for loop calculates the total number of dots (\texttt{numDot}) and dashes (\texttt{numDash}) in the message.

If there is more dots than dashes we build the durations based on the duration of a dot:

\begin{lstlisting}
if (numDot > numDash)
{
	averageDot /= numDot;
	bound13 = 2*averageDot;
	bound37 = 6*averageDot;
	std::cout << std::endl << "Dot:" << averageDot << std::endl;
}
\end{lstlisting}

In the reverse case, we trust the duration of the dash signal more:

\begin{lstlisting}
else
{
	if (numDash == 0 ) {return "";}
	averageDash /= numDash;
	bound13 = 2*averageDash/3;
	bound37 = 2*averageDash;
	std::cout << std::endl << "Dash:" << averageDash << std::endl;
}
\end{lstlisting}

Perhaps a bit bizzare invention are the variables \texttt{bound13} and \texttt{bound37}. Let's see what they are doing here.

At the very end, the function \texttt{arduino::output()} returns the string written in the Morse alphabet \texttt{messageReceived} which corresponds to the message that was captured by Arduino.

\chapter{Putting it all together}

Now comes the moment we've all been waiting for. It's time to put the two phases: \textbf{broadcasting} and \textbf{receiving} together and see how the whole project is working in all of its beauty!

The picture below shows our complete setup of the \textit{Objectif Morse}.

\begin{figure}[H]
\centering\includegraphics[width=14.5cm]{full_setup}
\caption{\textit{Objectif Morse} complete setup.}				
\label{fig:full_setup}
\end{figure}

\begin{figure}[H]
\centering\includegraphics[width=8cm]{scheme}
\caption{Scheme of the electronic circuits put together.}				
\label{fig:circuits}
\end{figure}

We have used two breadboards to completely separate the two electronic circuits. This allows for a little bit more debugging of the project because you can easily change the distance between the LED diode and the phototransistor. But of course you can build the two circuits on one breadboard too. You can also create a cardboard box to hide the LED-phototransistor couple - this will make the secret messages more secret as well as make the project work better in the brighter surroundings.

\begin{figure}[H]
\centering\includegraphics[width=8cm]{circuits}
\caption{Electronic circuits put together.}				
\label{fig:circuits_pic}
\end{figure}



\chapter{Post-credit scenes}

This last chapter is a collection of post-credit scenes where we present a few of our ideas of exploiting the machinery that we have created.

\section{It doesn't end here}



\subsubsection{Reading secret alien messages}

Now it's your time to have some more fun! Forget about the \textbf{broadcasting} part, take the flashlight and try to create the message yourself by shining on the phototransistor. Hopefully you'll do better then us!


\subsubsection{How far can it go?}

Approximately 22cm separation was the maximum that we've observed during daylight of a gloomy day, with closed window shades and with no artificial light in the room. 


\subsubsection{How fast can it go?}

The parameter \verb|dotTime| alows you to control the speed of the transmission. Feel free to play around with it! We've observed that \verb|dotTime < 2000 ms| is when the transmission errors begin to occur. It is also dependent on the distance between LED diode and the phototransistor and on the general luminosity of the surroundings.


\subsubsection{Sending a picture}

Can you imagine how uneffective it would be to transfer images between computers using Morse?

\subsubsection{Light to sound}

At some point we realized that it won't be a lot of effort to replace light Morse transmission with sound Morse transmission! Using a microphone and a buzzer you can achieve pretty much the same thing.

\section{Want to do more?}

There was a lot more ideas and unfortunately not always enough time.

One day we would like to extend the project to transmit messages over larger distances. Perhaps use a laser beam and a solar panel? Could this be a new way of the internet-free communication between neighbours? Although quite susceptible to the man-in-the-middle attack... But what if neighbours used an optical fiber hidden in the ground?...

As Cliff Stoll once said \cite{cliff_stoll}: 

\textit{I'm interested in seeing where the curiosity will lead to, not: oh, where have we been.}

We encourage you to explore, learn, make a lot of mistakes and the most important: have a lot of pleasure of finding things out. Perhaps we'll hear from you soon when you share your ideas with us!

\newpage

\begin{thebibliography}{50}

\bibitem{objectif_lune} \hyperlink{https://fr.wikipedia.org/wiki/Objectif_Lune}{\textit{Les Aventures De Tintin: Objectif Lune}}, Hergé

\bibitem{le_lotus_bleu} \hyperlink{https://fr.wikipedia.org/wiki/Le_Lotus_bleu}{\textit{Les Aventures De Tintin: Le Lotus Bleu}}, Hergé

\bibitem{ioperm} \hyperlink{http://man7.org/linux/man-pages/man2/ioperm.2.html}{\texttt{ioperm}}, Linux Programmer's Manual

\bibitem{cliff_stoll} \hyperlink{https://www.youtube.com/watch?v=xHEIOgONq6A}{Cliff Stoll: Good Science}

\end{thebibliography}

\end{document}
